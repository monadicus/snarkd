use snarkd_common::Digest;

use super::SerialRecord;

pub type TransactionId = [u8; 32];

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SerialTransaction {
    pub id: TransactionId,

    /// The root of the ledger commitment Merkle tree
    pub ledger_digest: Digest,

    /// The serial numbers of the records being spent
    pub old_serial_numbers: Vec<Digest>,

    pub new_commitments: Vec<Digest>,

    /// The commitment to the old record death and new record birth programs
    pub program_commitment: Digest,

    /// The root of the local data merkle tree
    pub local_data_root: Digest,

    /// A transaction value balance is the difference between input and output record balances.
    /// This value effectively becomes the transaction fee for the miner. Only coinbase transactions
    /// can have a negative value balance representing tokens being minted.
    pub value_balance: i64,

    /// Randomized signatures that allow for authorized delegation of transaction generation
    pub signatures: Vec<Digest>,

    /// Encrypted record and selector bits of the new records generated by the transaction
    pub new_records: Vec<Vec<u8>>,

    /// Zero-knowledge proof attesting to the valididty of the transaction
    pub transaction_proof: Vec<u8>,

    /// Public data associated with the transaction that must be unique among all transactions
    pub memorandum: Digest,

    /// The ID of the inner SNARK being used
    pub inner_circuit_id: Digest,
}

impl SerialTransaction {
    pub fn size(&self) -> usize {
        use std::mem::size_of;

        size_of::<SerialTransaction>()
            + size_of::<Digest>()
                * (self.old_serial_numbers.len()
                    + self.new_commitments.len()
                    + self.signatures.len())
            + size_of::<SerialRecord>() * self.new_records.len()
            + self.new_records.iter().map(|x| x.len()).sum::<usize>()
            + self.transaction_proof.len()
    }
}
